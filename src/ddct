#!/usr/bin/env python

from __future__ import (print_function, unicode_literals, division,
                        absolute_import)
"""
Datera Deployment Check Tool
"""

import argparse
import io
import json
import os
import sys


import common
from common import ff, gen_report, read_report, check, plugin_table
from validators import run_checks
from fixers import run_fixes, print_fixes

try:
    from dfs_sdk import get_api
except ImportError:
    get_api = None


VERSION = "v1.4.0"

VERSION_HISTORY = """
    v1.0.0 -- Initial version
    v1.0.1 -- Additional multipath.conf checks, Check IDs, tool versioning
    v1.0.2 -- Added report reading and file output
    v1.1.0 -- Adding support for running fixes based on report codes
    v1.2.0 -- Adding plugin support, moving cinder-volume to plugins
    v1.3.0 -- Created "check" decorator and changing wf/ff function signatures
    v1.4.0 -- Changed ddct.py to ddct
"""


CONFIG = {"mgmt_ip": "1.1.1.1",
          "vip1_ip": "10.0.1.1",
          "vip2_ip": "10.0.2.1",
          "username": "admin",
          "password": "password",
          "cluster_root_password": None,
          "cluster_root_keyfile": None}

GEN_CONFIG_FILE = "ddct.json"
DEFAULT_CONFIG_FILE = ".ddct.json"


def generate_config_file():
    print("Generating example config file: {}".format(GEN_CONFIG_FILE))
    with io.open(GEN_CONFIG_FILE, "w+") as f:
        try:
            json.dump(CONFIG, f, indent=4, sort_keys=True)
        except TypeError:
            # Python 2 compatibility
            f.write(json.dumps(CONFIG, indent=4, sort_keys=True).decode(
                'utf-8'))
        sys.exit(0)


@check("CONFIG")
def check_config(args):
    config = None
    if args.config_file:
        if not os.path.exists(args.config_file):
            raise EnvironmentError(
                "Config file {} not found".format(args.config_file))
        with io.open(args.config_file, "r") as f:
            config = json.load(f)
    elif os.path.exists(DEFAULT_CONFIG_FILE):
        with io.open(DEFAULT_CONFIG_FILE, "r") as f:
            config = json.load(f)
    else:
        print("No config file found.\nMust either have a {} file in current "
              "directory or manually specify config file via '-c' flag. "
              "\nA sample config file can be generated with the '-g' flag."
              "".format(
                  DEFAULT_CONFIG_FILE))
        return ff("Missing config file")
    return config


def main(args):
    if args.version:
        print("Datera Deployment Check Tool (DDCT) version: ", VERSION)
        sys.exit(0)
    common.VERBOSE = args.verbose
    common.WARNINGS = not args.disable_warnings
    if not get_api:
        print("Please install requirements listed in requirements.txt")
        sys.exit(1)
    # Generate or load config file
    if args.generate_config_file:
        generate_config_file()
        return 0
    config = check_config(args)
    config['api'] = get_api(
        config['mgmt_ip'], config['username'], config['password'], "v2.2")

    ran_fixes = False
    if args.print_fixes:
        print_fixes(args.use_plugins)
        sys.exit(0)

    if args.list_plugins:
        plugin_table()
        sys.exit(0)

    if args.in_report:
        report = read_report(args.in_report)
        if args.run_fixes:
            run_fixes(report.code_list(), config, plugins=args.use_plugins)
            ran_fixes = True
        else:
            print(report.generate())
            sys.exit(0)
    elif args.codes and args.run_fixes:
        run_fixes(args.codes, config, plugins=args.use_plugins)
        ran_fixes = True

    if ran_fixes:
        print("Running post-fix checks")
    else:
        print("Running checks")

    run_checks(config, plugins=args.use_plugins)
    gen_report(outfile=args.out, quiet=args.quiet)


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("-g", "--generate-config-file", action="store_true",
                        help="Generate config file example")
    parser.add_argument("-c", "--config-file",
                        help="Config file location")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Enables verbose output")
    parser.add_argument("-w", "--disable-warnings", action="store_true",
                        help="Disables showing warnings in output")
    parser.add_argument("-o", "--out", help="Output file.  Will still print "
                                            "to stdout unless -q option is "
                                            "provided")
    parser.add_argument("-q", "--quiet", action="store_true",
                        help="No output to stdout")
    parser.add_argument("-i", "--in-report", help="Report file location to "
                                                  "read in")
    parser.add_argument("-f", "--run-fixes", action="store_true",
                        help="Run fixes based on codes in provided report or "
                        "via manually specified codes")
    parser.add_argument("-d", "--codes", nargs="*",
                        help="Used for specifying codes manually when used "
                             "with the -f flag")
    parser.add_argument("-p", "--print-fixes", action="store_true",
                        help="Print out the tool's currently supported fixes "
                             "and codes")
    parser.add_argument("-l", "--list-plugins", action="store_true",
                        help="List available plugins")
    parser.add_argument("-u", "--use-plugins", nargs="*",
                        help="Accepts a space separated list of plugins")
    parser.add_argument("--version", action="store_true",
                        help="Print DDCT version")
    args = parser.parse_args()
    sys.exit(main(args))
